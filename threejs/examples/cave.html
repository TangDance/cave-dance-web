<head>
	<title>Cave Dance | CAMLab </title>
	<meta content="Dunhuang Cave Dance" name="description" />
	<meta content="Dunhuang Cave Dance" property="og:title" />
	<meta content="Dunhuang Cave Dance" property="og:description" />
	<meta property="og:type" content="website" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
	<meta charset="utf-8">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js" type="text/javascript"></script>
	<script src="https://cdn.jsdelivr.net/npm/fflate@0.7.2/umd/index.min.js" type="text/javascript"></script>
	<link href="https://assets-global.website-files.com/603fe89ec4bbcece7ee6a53a/61014076aa014a767ce9208c_favicon.png" rel="shortcut icon" type="image/x-icon" />
	<link href="https://assets-global.website-files.com/603fe89ec4bbcece7ee6a53a/610140795b9a3f0382a58e51_web-clip.png" rel="apple-touch-icon" />
	<script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=603fe89ec4bbcece7ee6a53a" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
	<link href="cave.css" rel="stylesheet" type="text/css" />
</head>

<body>

	<button class="menu" id="button_print" style="display:none">camera info</button>

	<div id="loading" class="loading">
		<div class="wait">
			<div class="wait-inner">
				<div class="wait_img-wrap">
					<div data-w-id="e8311aee-d434-6a91-e883-eae45438144d" class="wait_img"></div>
					<div data-w-id="a5f9b580-a290-06a9-c3a9-042380199875" class="wait-overlay"></div>
				</div>
				<div class="wait-content">
					<div class="hero-h1__wrap"><img src="https://chunweb.files.wordpress.com/2022/04/cave220.png" loading="lazy" alt="" class="hero-h1" /></div>
				</div>
				<div id="menu" style="opacity: 0.6">
					<div class="container" style="margin-top: 2rem">
			      <div class="title-container">
			        <div class="title">
			          <h1>敦煌莫高窟第220窟</h1>
								<h2>Mogao Cave 220</h2>
			        </div>
			      </div>
			    </div>
				</div>

			</div>
		</div>
	</div>

	<aside id="instructions">
	  <ul id="directional">
	    <li>W</li>
	    <li>A</li>
	    <li>D</li>
	    <li>S</li>
	  </ul>
	  <ul id="rotational">
	    <li><span>&#8227;</span></li>
	    <li>&#8227;</li>
	    <li>&#8227;</li>
	    <li><span>&#8227;</span></li>
	  </ul>
	</aside>

	<div class="tour">
		<div class="mainline">敦煌莫高窟第220窟</div>
		<div class="subline">Mogao Cave 220</div>

		<div class="buttonlines">
			<div class="buttonline">
				<div class="animation-circle-container scene_start" id="scene1_start">
			      <div class="circle"></div>
			      <div class="circle2"></div>
			      <div class="logo-div-send">
			      </div>
				</div>
				<button class="menu" id="button_scene1">主室北壁</button>
			</div>

			<div class="buttonline">
				<div class="animation-circle-container scene_start" id="scene2_start">
			      <div class="circle"></div>
			      <div class="circle2"></div>
			      <div class="logo-div-send">
			      </div>
				</div>
				<button class="menu" id="button_scene2">主室南壁</button>
			</div>

			<div class="buttonline">
				<div class="animation-circle-container scene_start" style="opacity:0" >
			      <div class="circle"></div>
			      <div class="circle2"></div>
			      <div class="logo-div-send">
			      </div>
				</div>
				<button class="menu" id="button_reset">重新开始</button>
			</div>
		</div>
	</div>

	<div id="menu">
		<div class="container">
      <div class="title-container">
        <div class="title">
          <h1>敦煌莫高窟第220窟</h1>
					<h2>Mogao Cave 220</h2>
					<div id="loading-title" class="loading">
						Loading...
					</div>
          <button class="explore">Start Exploring</button>
        </div>
      </div>
    </div>
	</div>

	<div id="scene1_overlay_container" class="scene">
		<div id="scene1_close" class="close cta-img menu-close">
			<img src="https://assets-global.website-files.com/603fe89ec4bbcece7ee6a53a/60c339990e8c2e33a380b5c6_arrow.svg" loading="lazy" class=" img ico" />
		</div>
		<video id="scene1_overlay_video" playsinline loop class="b-hero__bg-video" aria-label="Background Video">
			<source src="https://chunweb.files.wordpress.com/2022/03/body.mp4" type="video/mp4">
		</video>
	</div>

	<div id="scene2_overlay_container" class="scene">
		<div id="scene2_close" class="close cta-img menu-close">
			<img src="https://assets-global.website-files.com/603fe89ec4bbcece7ee6a53a/60c339990e8c2e33a380b5c6_arrow.svg" loading="lazy" class=" img ico" />
		</div>
		<video id="scene2_overlay_video" playsinline loop class="b-hero__bg-video" aria-label="Background Video">
			<source src="https://chunweb.files.wordpress.com/2022/03/body.mp4" type="video/mp4">
		</video>
	</div>


	<script type="importmap">
		{
      "imports": {
        "three": "../build/three.module.js"
      }
    }
  </script>

	<script type="module">
		// CODE REFERENCE: https://codepen.io/HoraceShmorace/pen/XWegwxE, which
		// demostrates a 1st person camera supporting both ROTATIONAL
		// and DIRECTIONAL movement

		import * as THREE from 'three';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { FBXLoader } from './jsm/loaders/FBXLoader.js';
		import { OrbitControls } from '//cdn.skypack.dev/three@0.136/examples/jsm/controls/OrbitControls.js';
		import { Reflector } from '//cdn.skypack.dev/three@0.136/examples/jsm/objects/Reflector.js';

		const Settings = function() {
			this.d = 0.05; // scaler of cave model
			this.groundWidth = 10000*this.d;
			this.groundHeight = 10000*this.d;
			this.showGridHelper = false;
			this.showAxesHelper = false;
			this.groundVisible = false;
			this.addLight = true;
			this.trackCamera = false;
			this.fov = 60;
			this.walkerModelSize = 0.0005;
			this.walkerTurnSpeed = Math.PI * 0.02;
    };

		const settings = new Settings();
		let  camera; //PerspectiveCamera
		let orbitalCamera;  //orbitalCamera
		let canvas, renderer, scene, orbitControls, flyControls;
		const explore = $(".explore");
		const reset = $("#button_reset");
		const printCameraInfo = $("#button_print");
		const scene1 = $("#button_scene1");
		const scene2 = $("#button_scene2");
		let cameraDirection = new THREE.Vector3();
		let scene1_open = false;

		const PLAYER_INITIAL_POSITION = {x: -20,  y: -70, z: -70};

		const CAMERA_POSITIONS = {
			start: {x: 0, y: 0, z: 0},
			cave_center: {x: 0, y: 0, z: -250}
		}

		const {
		  devicePixelRatio,
		  innerHeight: viewportHeight,
		  innerWidth: viewportWidth
		} = window

		class Scene extends THREE.Scene {
		  #controls
		  #orbital
		  #player
		  #prevTimestamp
		  #renderer
		  #scene

		  static timeDilation = 0.4;

		  constructor (props) {
		    super(props)

				scene = this;
		    this.#renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer = this.#renderer;

		    this.#controls = {
		      position: new KeyboardInput({
		        left: 'a',
		        right: 'd',
		        up: 's',
		        down: 'w'
		      }),
					// TODO remove this
		      rotation: new KeyboardInput({
		        left: 'arrowleft',
		        right: 'arrowright',
		        up: 'arrowup',
		        down: 'arrowdown'
		      })
		    }

		    this.#player = new Player({
		      animationNames: ['idle', 'walk', 'run'],
		      modelName: 'root',
		      onLoad: () => (document.querySelector('#loading').style.display = 'none'),
		      path: 'https://assets.codepen.io/829639/'
		    })
				// this effectively moves the walker
				this.#player.position.set(PLAYER_INITIAL_POSITION.x, PLAYER_INITIAL_POSITION.y, PLAYER_INITIAL_POSITION.z);
		    this.add(this.#player)

		    this.#orbital = new OrbitalCamera(settings.fov, viewportWidth / viewportHeight, 1, 1000);
				orbitalCamera = this.#orbital;
		    this.#player.add(this.#orbital) // Add the orbital to the player, not to the scene

				canvas = this.#renderer.domElement;
		    document.body.appendChild(canvas);
		    this.#renderer.setAnimationLoop(this.#render);


				// orbitControls = new OrbitControls(camera, renderer.domElement);
				// orbitControls.update();

				const loader = new GLTFLoader().setPath( 'models/dunhuang/Cave220_GLTF/' );
				loader.load( 'model.gltf',
					function ( gltf ) {
						const cave = gltf.scene;
						cave.traverse( (e)=>{
							if( e.type === "Mesh") {
								if ( e.material ) {
									e.material.side = THREE.FrontSide;
								}
							}
						});
						cave.position.set(-50, -100, -100);
						cave.scale.set(settings.d, settings.d, settings.d);
						scene.add(cave);
						renderer.render(scene, camera);
						TweenMax.to("#loading", 1, {opacity:0, display:"none"});
						TweenMax.to(".container", 2, {opacity:1});
						//TweenMax.to(".title", 4, {opacity:1});
						TweenMax.to(".explore", 5, {opacity:1});
						TweenMax.to("#loading-title", 0.5, {opacity:0, display:"none"});
					},
					function ( xhr ) {	// called while loading is progressing
					//	console.log( ( xhr.loaded / xhr.total * 100 ) + '% of the cave model is loaded' );
					},
					function ( error ) {
						console.log( 'An error happened loading the cave model' );
					}
				);

				if (settings.groundVisible) {
					 this.#addGround()
				}

				if (settings.showAxesHelper) {
					const axesHelper = new THREE.AxesHelper( 50000 );
					scene.add( axesHelper );
				}

				if (settings.addLight) {
					this.#addLights()
				}

		  }

		  #addGround () {
				const groundGeometry = new THREE.PlaneGeometry(settings.groundWidth, settings.groundHeight);
				const planeMesh = new THREE.Mesh( groundGeometry,
						new THREE.MeshBasicMaterial({
								side: THREE.DoubleSide,
								visible: true
						})
				);
				planeMesh.rotateX(-Math.PI / 2);
				planeMesh.name = 'ground';
				this.add(planeMesh);
		  }

		  #addLights() {
				const ambientLight = new THREE.AmbientLight( 0xffffff, 1);
				this.add( ambientLight );

				const directional = new THREE.DirectionalLight(0xffffff, 3)
		    directional.position.set(50, 50, 50)
		    directional.target.position.set(0, 0, 0)
		    this.add(directional)

				const pointLight = new THREE.PointLight( 0xffffff, 4);
				pointLight.position.set(0, 0, 0);
				camera.add( pointLight );
		  }

		  #update = elapsedTime => {
				this.#renderer.setSize(window.innerWidth, window.innerHeight)

			 // Rotate the camera
			 // TODO this will cause everything black out
			 // const easeIn = 91
			  let { x: yRotation, y: xRotation } = this.#controls.rotation
			 // xRotation = Math.pow(xRotation, easeIn)
			 const cameraRotation = new THREE.Euler(xRotation, yRotation, 0)
			 //this.#orbital.update(elapsedTime, cameraRotation)

		    // Reposition the player
		    const { x: xPos, y: zPos } = this.#controls.position
		    const playerPosition = new THREE.Vector3(xPos, 0, zPos)
		    playerPosition.multiplyScalar(Scene.timeDilation)
		    // This applies any orbital rotation to the new player position so that the
				// "forward" direction (the A key) will always move the player "up" on the screen
				// (and the same for left, down, and right).
		    playerPosition.applyEuler(this.#orbital.rotation)
		    this.#player.update(elapsedTime, playerPosition)
		  }

		  #render = timestamp => {
		    if (this.#prevTimestamp === undefined) this.#prevTimestamp = timestamp

		    const elapsedTime = (timestamp - this.#prevTimestamp) / 1000;
		    this.#renderer.render(this, this.#orbital.camera);
		    this.#update(elapsedTime);
		    this.#prevTimestamp = timestamp;
		    this.#renderer.render(this, this.#orbital.camera);
		  }
		}

		/**
		 * Creates a THREE.PerspectiveCamera wrapped in a THREE.Object3D.
		 	 As a child of the Object3D, the camera is positioned in the Object3D's local space.
			 The Object3D can thus be rotated, allowing the camera to rotate as an orbital, around the Object3D's origin.
		 * @class
		 */
		class OrbitalCamera extends THREE.Object3D {
		  #originalCameraAngle
		  #originalCameraHeight

		  /**
		   * Accepts standard parameters for a THREE.PerspectiveCamera
		   */
		  constructor (fov, aspect, near, far) {
		    super()

		    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
				camera = this.camera;
		    this.add(this.camera)
		    this.#originalCameraAngle = this.camera.rotation.x
		    this.#originalCameraHeight = this.camera.position.y
		  }

		  update (elapsedTime, rotation) {
		    if (rotation instanceof THREE.Euler) {
		      const pitch = rotation.x * -.5
		      const yaw = this.rotation.y + rotation.y * -elapsedTime

		      this.rotation.set(this.rotation.x, yaw, this.rotation.z)

		      const camAltitude = this.camera.position.clone()
		      camAltitude.setY(this.#originalCameraHeight + (rotation.x * 10))
		      this.camera.position.lerp(camAltitude, .1)

		      const camPitch = this.camera.quaternion.clone()
		      camPitch.setFromAxisAngle(
		        new THREE.Vector3(1, 0, 0),
		        this.#originalCameraAngle - rotation.x * .5
		      )
		      this.camera.quaternion.slerp(camPitch, .1)
		    }

		    this.camera.aspect = window.innerWidth / window.innerHeight
		    this.camera.updateProjectionMatrix()
		  }
		}

		class Player extends THREE.Group {
		  #action
		  #actionList = {}
		  #areModelsLoaded = false
		  #mixer
		  #model

		  constructor (props) {
		    super()

		    const { animationNames, modelName, onLoad, path } = props
		    const loader =  new FBXLoader()
		    loader.setPath(path)
		    loader.load(
		      `${modelName}.fbx`,
		      model => {
		        model.scale.setScalar(settings.walkerModelSize)
					//	model.position.set(0, -200, 0)

		        model.traverse(mesh => {
		          mesh.castShadow = true
		          if (mesh.material?.name === 'asdf1:Beta_HighLimbsGeoSG2') {
		            mesh.material.color.setHex(0x888888) //0x333333
		            mesh.metalicness = 1
		            mesh.roughness = 0
		          } else if (mesh.material?.name === 'Beta_Joints_MAT') {
		            mesh.material.color.setRGB(
							0,
							0,
							0)}
		        })

		        model.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)
		        this.#model = model
		        this.add(model)
		        this.#mixer = new THREE.AnimationMixer(this.#model)

		        const loadingManager = new THREE.LoadingManager()
		        const loader = new FBXLoader(loadingManager)
		        loader.setPath(path)
		        loadingManager.onLoad = () => {
		          this.#areModelsLoaded = true
		          this.#setAction('idle')
		          if (typeof onLoad === 'function') onLoad()
		        }

		        animationNames.forEach(name => {
		          loader.load(`${name}.fbx`, model => {
		            const clip = model.animations[0]
		            const action = this.#mixer.clipAction(clip)
		            action.name = name
		            this.#actionList[name] = action
		          })
		        })
		      },
		      null,
		      e => console.log(e)
		    )
		  }

		  update = (elapsedTime, movement) => {
		    if (!this.#action) return
		    this.#animate(elapsedTime, movement)
		    this.#move(elapsedTime, movement)
		  }

		  #animate = (elapsedTime, movement) => {
		    const { x, z } = movement

		    const speed = Math.min(Math.abs(x) + Math.abs(z), 1)

		    let action = 'idle'
		    if (speed === 0) action = 'idle'
		    else if (speed < 1) action = 'walk'
		    else action = 'run'

		    this.#setAction(action)
		   // this.#mixer.update(elapsedTime)

				if (settings.trackCamera) {
					camera.getWorldDirection(cameraDirection); // this copies the camera's unit vector direction to cameraDirection
					cameraDirection.set(cameraDirection.x * 100, cameraDirection.y * 100, cameraDirection.z * 100); 	// scale the unit vector up to get a more intuitive value
				}
		  }

		  #move = (elapsedTime, movement) => {
		    if (!movement instanceof THREE.Vector3) return
		    if (movement.x === 0 && movement.z === 0) return

		    const nextPosition = this.position.clone()
		    nextPosition.add(movement)

		    const angle =
		      Math.PI +
		      Math.atan2(
		        this.position.x - nextPosition.x,
		        this.position.z - nextPosition.z
		      )

		    this.position.copy(nextPosition)

		    if (this.#model)
		      this.#model.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), angle)
		  }

		  #setAction (name) {
		    const prevAction = this.#action
		    if (prevAction?.name === name) return

		    this.#action = this.#actionList[name]

		    if (prevAction) {
		      this.#action.time = 0.1
		      this.#action.enabled = true
		      this.#action.setEffectiveTimeScale(Scene.timeDilation)
		      this.#action.setEffectiveWeight(1.0)
		      this.#action.crossFadeFrom(prevAction, 0.5, true)
		    }

		    this.#action.play();
		  }
		}

		class KeyboardInput extends THREE.Vector3 {
		  #activeKeys = new Set();
		  #keyMapping = {};

		  constructor (keyMapping) {
		    super();
		    if (keyMapping) this.#keyMapping = keyMapping;
		    window.addEventListener('keydown', this.onKeyDown);
		    window.addEventListener('keyup', this.onKeyUp);
		  }

		  onKeyDown = e => {
		    const key = e.key.toLowerCase();
		    const activeKeys = this.#activeKeys;
		    const { left, right, up, down } = this.#keyMapping;

		    activeKeys.add(key);

		    switch (key) {
					case "arrowleft":
						camera.rotation.y -= settings.walkerTurnSpeed;
						break;
					case "arrowright":
						camera.rotation.y += settings.walkerTurnSpeed;
						break;
					case "arrowup":
						camera.rotation.x += settings.walkerTurnSpeed;
						break;
					case "arrowdown":
						camera.rotation.x -= settings.walkerTurnSpeed;
						break;
		      case left:
		        this.setX(-1);
		        break;
		      case right:
		        this.setX(1);
		        break;
		      case up:
		        this.setY(1);
		        break;
		      case down:
		        this.setY(-1);
		        break;
		      default:
		        break;
		    }
		  }

		  onKeyUp = e => {
		    const key = e.key.toLowerCase();
		    const activeKeys = this.#activeKeys
		    const { left, right, up, down } = this.#keyMapping

		    activeKeys.delete(key)
		    switch (key) {
		      case left:
		        if (!activeKeys.has(right)) this.setX(0)
		        break
		      case right:
		        if (!activeKeys.has(left)) this.setX(0)
		        break
		      case up:
		        if (!activeKeys.has(down)) this.setY(0)
		        break
		      case down:
		        if (!activeKeys.has(up)) this.setY(0)
		        break
		      default:
		        break
		    }
		  }
		}

		new Scene();

		function setEventListeners() {
			explore.click(() => {
				if (!gsap.isTweening(camera.position)) {
					const initPos = CAMERA_POSITIONS['start'];
					gsap.to(camera.position, {
						duration: 5,
						z: initPos.z-180,
						ease: "power3.inOut",
						onComplete: () => {
							console.log("onComplete explore gsap");
						}
					});
				}
				TweenMax.to(".container", 0.1, {opacity:0, display:"none"});
				TweenMax.to(".tour", 2, {opacity:1});
			});

			scene1.click(() => {
				if (!gsap.isTweening(camera.position)) {
					let cave = CAMERA_POSITIONS['cave_center'];
					gsap.timeline()
						.to(camera.position, { x: cave.x, y: cave.y, z: cave.z,
							onComplete: () => {
								camera.rotation.x = 0;
								camera.rotation.y = 0;
							}
						})
						.to(camera.position, { x: -50,
								onComplete: () => {
									const startY = camera.rotation.y;
									gsap.to(camera.rotation, {duration: 4, y: startY - 20*settings.walkerTurnSpeed });

									$("#scene1_start").animate({
									    opacity: 1
									  }, 1000, function() {
									    // Animation complete.
									  });
								}
						})
				}
			});

			scene2.click(() => {
				if (!gsap.isTweening(camera.position)) {
					let cave = CAMERA_POSITIONS['cave_center'];
					gsap.timeline()
					  .to(camera.position, { x: cave.x, y: cave.y, z: cave.z,
							onComplete: () => {
								camera.rotation.x = 0;
								camera.rotation.y = 0;
							}
						})
						.to(camera.position, { x: 50,
								onComplete: () => {
									const startY = camera.rotation.y;
									gsap.to(camera.rotation, {duration: 4, y: startY + 20*settings.walkerTurnSpeed });

									$("#scene2_start").animate({
											opacity: 1
										}, 1000, function() {
											// Animation complete.
										});
								}
						})
				}
			});

			$("#scene1_start").click(() => {
				$("#scene1_overlay_container").show();
				document.getElementById("scene1_overlay_video").play();
			});

			$("#scene1_close").click(() => {
				document.getElementById("scene1_overlay_video").pause();
				clearTour();
				$("#scene1_overlay_container").hide();
			});

			$("#scene2_start").click(() => {
				$("#scene2_overlay_container").show();
				document.getElementById("scene2_overlay_video").play();
			});

			$("#scene2_close").click(() => {
				document.getElementById("scene2_overlay_video").pause();
				clearTour();
				$("#scene2_overlay_container").hide();
			});

			reset.click(() => {
				let cave = CAMERA_POSITIONS['start'];
				gsap.timeline()
					.to(camera.position, { x: cave.x, y: cave.y, z: cave.z,
						onComplete: () => {
							camera.rotation.x = 0;
							camera.rotation.y = 0;
						}
					})
			});

			printCameraInfo.click(() => {
				if (!settings.trackCamera) {
					alert('settings trackCamera is false!');
					return;
				}
				const pos = `Position: {x: ${camera.position.x.toFixed(1)}, y: ${camera.position.y.toFixed(1)}, z: ${camera.position.z.toFixed(1)}}`
				const lookat = `LookAt: {x: ${(camera.position.x + cameraDirection.x).toFixed(1)}, y: ${(camera.position.y + cameraDirection.y).toFixed(1)}, z:  ${(camera.position.z + cameraDirection.z).toFixed(1)}}`
				console.log(pos);
				console.log(lookat);
				console.log("orbitalCamera", orbitalCamera)
			} );

			window.addEventListener('resize', function() {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();
			    renderer.setSize(window.innerWidth, window.innerHeight);
			});
		}


		function clearTour() {
			$("#scene1_start").animate({ opacity: 0 }, 30);
			$("#scene2_start").animate({ opacity: 0 }, 30);
			// Array.from($(".scene_start")).forEach((item, i) => {
			// 	item.animate({ opacity: 0 }, 30);
			// });
		}


		setEventListeners();

  </script>
</body>
